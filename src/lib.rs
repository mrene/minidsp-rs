/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

#[link(name = "cec")] extern {}

pub const CEC_LIB_VERSION_MAJOR: u32 = 4;
pub const CEC_LIB_VERSION_MAJOR_STR: &'static [u8; 2usize] = b"4\0";
pub const CEC_LIB_VERSION_MINOR: u32 = 0;
pub const CEC_DEFAULT_PHYSICAL_ADDRESS: u32 = 4096;
pub const CEC_DEFAULT_HDMI_PORT: u32 = 1;
pub const CEC_DEFAULT_BASE_DEVICE: u32 = 0;
pub const CEC_BUTTON_TIMEOUT: u32 = 500;
pub const CEC_DOUBLE_TAP_TIMEOUT_MS: u32 = 200;
pub const CEC_POWER_STATE_REFRESH_TIME: u32 = 30000;
pub const CEC_FW_VERSION_UNKNOWN: u32 = 65535;
pub const CEC_FW_BUILD_UNKNOWN: u32 = 0;
pub const CEC_CONNECT_TRIES: u32 = 3;
pub const CEC_PHYSICAL_ADDRESS_TV: u32 = 0;
pub const CEC_MIN_PHYSICAL_ADDRESS: u32 = 4096;
pub const CEC_MAX_PHYSICAL_ADDRESS: u32 = 65534;
pub const CEC_INVALID_PHYSICAL_ADDRESS: u32 = 65535;
pub const CEC_MIN_VENDORID: u32 = 1;
pub const CEC_MAX_VENDORID: u32 = 16777214;
pub const CEC_INVALID_VENDORID: u32 = 16777215;
pub const CEC_MIN_HDMI_PORTNUMBER: u32 = 1;
pub const CEC_MAX_HDMI_PORTNUMBER: u32 = 15;
pub const CEC_HDMI_PORTNUMBER_NONE: u32 = 0;
pub const CEC_DEFAULT_SETTING_ACTIVATE_SOURCE: u32 = 1;
pub const CEC_DEFAULT_SETTING_POWER_OFF_SHUTDOWN: u32 = 1;
pub const CEC_DEFAULT_SETTING_POWER_OFF_ON_STANDBY: u32 = 1;
pub const CEC_DEFAULT_DEVICE_LANGUAGE: &'static [u8; 4usize] = b"eng\0";
pub const CEC_DEFAULT_SETTING_AUTODETECT_ADDRESS: u32 = 0;
pub const CEC_DEFAULT_SETTING_GET_SETTINGS_FROM_ROM: u32 = 0;
pub const CEC_DEFAULT_SETTING_CEC_VERSION: u32 = 5;
pub const CEC_DEFAULT_TRANSMIT_RETRY_WAIT: u32 = 500;
pub const CEC_DEFAULT_TRANSMIT_TIMEOUT: u32 = 1000;
pub const CEC_DEFAULT_TRANSMIT_WAIT: u32 = 1000;
pub const CEC_DEFAULT_TRANSMIT_RETRIES: u32 = 1;
pub const CEC_DEFAULT_CONNECT_TIMEOUT: u32 = 10000;
pub const CEC_DEFAULT_CONNECT_RETRY_WAIT: u32 = 1000;
pub const CEC_SERIAL_DEFAULT_BAUDRATE: u32 = 38400;
pub const CEC_CLEAR_INPUT_DEFAULT_WAIT: u32 = 1000;
pub const CEC_ACTIVE_SOURCE_SWITCH_RETRY_TIME_MS: u32 = 1000;
pub const CEC_FORWARD_STANDBY_MIN_INTERVAL: u32 = 10000;
pub const CEC_DEFAULT_COMBO_TIMEOUT_MS: u32 = 1000;
pub const CEC_RPI_VIRTUAL_PATH: &'static [u8; 13usize] = b"Raspberry Pi\0";
pub const CEC_RPI_VIRTUAL_COM: &'static [u8; 4usize] = b"RPI\0";
pub const CEC_TDA995x_PATH: &'static [u8; 13usize] = b"/dev/hdmicec\0";
pub const CEC_TDA995x_VIRTUAL_COM: &'static [u8; 6usize] = b"CuBox\0";
pub const CEC_EXYNOS_PATH: &'static [u8; 9usize] = b"/dev/CEC\0";
pub const CEC_EXYNOS_VIRTUAL_COM: &'static [u8; 7usize] = b"Exynos\0";
pub const CEC_MAX_DATA_PACKET_SIZE: u32 = 64;
pub const CEC_AOCEC_PATH: &'static [u8; 11usize] = b"/dev/aocec\0";
pub const CEC_AOCEC_VIRTUAL_COM: &'static [u8; 6usize] = b"AOCEC\0";
pub const CEC_MIN_LIB_VERSION: u32 = 4;
pub const CEC_FEATURE_CONFIGURABLE_COMBO_KEY: u32 = 1;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
#[doc = "!< CEC_ABORT_REASON_UNRECOGNIZED_OPCODE"]
pub const CEC_ABORT_REASON_UNRECOGNIZED_OPCODE: cec_abort_reason = 0;
#[doc = "!< CEC_ABORT_REASON_NOT_IN_CORRECT_MODE_TO_RESPOND"]
pub const CEC_ABORT_REASON_NOT_IN_CORRECT_MODE_TO_RESPOND: cec_abort_reason = 1;
#[doc = "!< CEC_ABORT_REASON_CANNOT_PROVIDE_SOURCE"]
pub const CEC_ABORT_REASON_CANNOT_PROVIDE_SOURCE: cec_abort_reason = 2;
#[doc = "!< CEC_ABORT_REASON_INVALID_OPERAND"]
pub const CEC_ABORT_REASON_INVALID_OPERAND: cec_abort_reason = 3;
#[doc = "!< CEC_ABORT_REASON_REFUSED"]
pub const CEC_ABORT_REASON_REFUSED: cec_abort_reason = 4;
pub type cec_abort_reason = u32;
pub const CEC_ANALOGUE_BROADCAST_TYPE_CABLE: cec_analogue_broadcast_type = 0;
pub const CEC_ANALOGUE_BROADCAST_TYPE_SATELLITE: cec_analogue_broadcast_type = 1;
pub const CEC_ANALOGUE_BROADCAST_TYPE_TERRESTIAL: cec_analogue_broadcast_type = 2;
pub type cec_analogue_broadcast_type = u32;
pub const CEC_AUDIO_RATE_RATE_CONTROL_OFF: cec_audio_rate = 0;
pub const CEC_AUDIO_RATE_STANDARD_RATE_100: cec_audio_rate = 1;
pub const CEC_AUDIO_RATE_FAST_RATE_MAX_101: cec_audio_rate = 2;
pub const CEC_AUDIO_RATE_SLOW_RATE_MIN_99: cec_audio_rate = 3;
pub const CEC_AUDIO_RATE_STANDARD_RATE_100_0: cec_audio_rate = 4;
pub const CEC_AUDIO_RATE_FAST_RATE_MAX_100_1: cec_audio_rate = 5;
pub const CEC_AUDIO_RATE_SLOW_RATE_MIN_99_9: cec_audio_rate = 6;
pub type cec_audio_rate = u32;
pub const CEC_AUDIO_MUTE_STATUS_MASK: cec_audio_status = 128;
pub const CEC_AUDIO_VOLUME_STATUS_MASK: cec_audio_status = 127;
pub const CEC_AUDIO_VOLUME_MIN: cec_audio_status = 0;
pub const CEC_AUDIO_VOLUME_MAX: cec_audio_status = 100;
pub const CEC_AUDIO_VOLUME_STATUS_UNKNOWN: cec_audio_status = 127;
pub type cec_audio_status = u32;
pub const CEC_FALSE: cec_boolean = 0;
pub const CEC_TRUE: cec_boolean = 1;
pub type cec_boolean = u32;
pub const CEC_VERSION_UNKNOWN: cec_version = 0;
pub const CEC_VERSION_1_2: cec_version = 1;
pub const CEC_VERSION_1_2A: cec_version = 2;
pub const CEC_VERSION_1_3: cec_version = 3;
pub const CEC_VERSION_1_3A: cec_version = 4;
pub const CEC_VERSION_1_4: cec_version = 5;
pub type cec_version = u32;
pub const CEC_CHANNEL_NUMBER_FORMAT_MASK: cec_channel_identifier = 4227858432;
pub const CEC_1_PART_CHANNEL_NUMBER: cec_channel_identifier = 67108864;
pub const CEC_2_PART_CHANNEL_NUMBER: cec_channel_identifier = 134217728;
pub const CEC_MAJOR_CHANNEL_NUMBER_MASK: cec_channel_identifier = 67043328;
pub const CEC_MINOR_CHANNEL_NUMBER_MASK: cec_channel_identifier = 65535;
pub type cec_channel_identifier = u32;
pub const CEC_DECK_CONTROL_MODE_SKIP_FORWARD_WIND: cec_deck_control_mode = 1;
pub const CEC_DECK_CONTROL_MODE_SKIP_REVERSE_REWIND: cec_deck_control_mode = 2;
pub const CEC_DECK_CONTROL_MODE_STOP: cec_deck_control_mode = 3;
pub const CEC_DECK_CONTROL_MODE_EJECT: cec_deck_control_mode = 4;
pub type cec_deck_control_mode = u32;
pub const CEC_DECK_INFO_PLAY: cec_deck_info = 17;
pub const CEC_DECK_INFO_RECORD: cec_deck_info = 18;
pub const CEC_DECK_INFO_PLAY_REVERSE: cec_deck_info = 19;
pub const CEC_DECK_INFO_STILL: cec_deck_info = 20;
pub const CEC_DECK_INFO_SLOW: cec_deck_info = 21;
pub const CEC_DECK_INFO_SLOW_REVERSE: cec_deck_info = 22;
pub const CEC_DECK_INFO_FAST_FORWARD: cec_deck_info = 23;
pub const CEC_DECK_INFO_FAST_REVERSE: cec_deck_info = 24;
pub const CEC_DECK_INFO_NO_MEDIA: cec_deck_info = 25;
pub const CEC_DECK_INFO_STOP: cec_deck_info = 26;
pub const CEC_DECK_INFO_SKIP_FORWARD_WIND: cec_deck_info = 27;
pub const CEC_DECK_INFO_SKIP_REVERSE_REWIND: cec_deck_info = 28;
pub const CEC_DECK_INFO_INDEX_SEARCH_FORWARD: cec_deck_info = 29;
pub const CEC_DECK_INFO_INDEX_SEARCH_REVERSE: cec_deck_info = 30;
pub const CEC_DECK_INFO_OTHER_STATUS: cec_deck_info = 31;
pub const CEC_DECK_INFO_OTHER_STATUS_LG: cec_deck_info = 32;
pub type cec_deck_info = u32;
pub const CEC_DEVICE_TYPE_TV: cec_device_type = 0;
pub const CEC_DEVICE_TYPE_RECORDING_DEVICE: cec_device_type = 1;
pub const CEC_DEVICE_TYPE_RESERVED: cec_device_type = 2;
pub const CEC_DEVICE_TYPE_TUNER: cec_device_type = 3;
pub const CEC_DEVICE_TYPE_PLAYBACK_DEVICE: cec_device_type = 4;
pub const CEC_DEVICE_TYPE_AUDIO_SYSTEM: cec_device_type = 5;
pub type cec_device_type = u32;
pub const CEC_DISPLAY_CONTROL_DISPLAY_FOR_DEFAULT_TIME: cec_display_control = 0;
pub const CEC_DISPLAY_CONTROL_DISPLAY_UNTIL_CLEARED: cec_display_control = 64;
pub const CEC_DISPLAY_CONTROL_CLEAR_PREVIOUS_MESSAGE: cec_display_control = 128;
pub const CEC_DISPLAY_CONTROL_RESERVED_FOR_FUTURE_USE: cec_display_control = 192;
pub type cec_display_control = u32;
pub const CEC_EXTERNAL_SOURCE_SPECIFIER_EXTERNAL_PLUG: cec_external_source_specifier = 4;
pub const CEC_EXTERNAL_SOURCE_SPECIFIER_EXTERNAL_PHYSICAL_ADDRESS: cec_external_source_specifier =
    5;
pub type cec_external_source_specifier = u32;
pub const CEC_MENU_REQUEST_TYPE_ACTIVATE: cec_menu_request_type = 0;
pub const CEC_MENU_REQUEST_TYPE_DEACTIVATE: cec_menu_request_type = 1;
pub const CEC_MENU_REQUEST_TYPE_QUERY: cec_menu_request_type = 2;
pub type cec_menu_request_type = u32;
pub const CEC_MENU_STATE_ACTIVATED: cec_menu_state = 0;
pub const CEC_MENU_STATE_DEACTIVATED: cec_menu_state = 1;
pub type cec_menu_state = u32;
pub const CEC_PLAY_MODE_PLAY_FORWARD: cec_play_mode = 36;
pub const CEC_PLAY_MODE_PLAY_REVERSE: cec_play_mode = 32;
pub const CEC_PLAY_MODE_PLAY_STILL: cec_play_mode = 37;
pub const CEC_PLAY_MODE_FAST_FORWARD_MIN_SPEED: cec_play_mode = 5;
pub const CEC_PLAY_MODE_FAST_FORWARD_MEDIUM_SPEED: cec_play_mode = 6;
pub const CEC_PLAY_MODE_FAST_FORWARD_MAX_SPEED: cec_play_mode = 7;
pub const CEC_PLAY_MODE_FAST_REVERSE_MIN_SPEED: cec_play_mode = 9;
pub const CEC_PLAY_MODE_FAST_REVERSE_MEDIUM_SPEED: cec_play_mode = 10;
pub const CEC_PLAY_MODE_FAST_REVERSE_MAX_SPEED: cec_play_mode = 11;
pub const CEC_PLAY_MODE_SLOW_FORWARD_MIN_SPEED: cec_play_mode = 21;
pub const CEC_PLAY_MODE_SLOW_FORWARD_MEDIUM_SPEED: cec_play_mode = 22;
pub const CEC_PLAY_MODE_SLOW_FORWARD_MAX_SPEED: cec_play_mode = 23;
pub const CEC_PLAY_MODE_SLOW_REVERSE_MIN_SPEED: cec_play_mode = 25;
pub const CEC_PLAY_MODE_SLOW_REVERSE_MEDIUM_SPEED: cec_play_mode = 26;
pub const CEC_PLAY_MODE_SLOW_REVERSE_MAX_SPEED: cec_play_mode = 27;
pub type cec_play_mode = u32;
pub const CEC_POWER_STATUS_ON: cec_power_status = 0;
pub const CEC_POWER_STATUS_STANDBY: cec_power_status = 1;
pub const CEC_POWER_STATUS_IN_TRANSITION_STANDBY_TO_ON: cec_power_status = 2;
pub const CEC_POWER_STATUS_IN_TRANSITION_ON_TO_STANDBY: cec_power_status = 3;
pub const CEC_POWER_STATUS_UNKNOWN: cec_power_status = 153;
pub type cec_power_status = u32;
pub const CEC_RECORD_SOURCE_TYPE_OWN_SOURCE: cec_record_source_type = 1;
pub const CEC_RECORD_SOURCE_TYPE_DIGITAL_SERVICE: cec_record_source_type = 2;
pub const CEC_RECORD_SOURCE_TYPE_ANALOGUE_SERVICE: cec_record_source_type = 3;
pub const CEC_RECORD_SOURCE_TYPE_EXTERNAL_PLUS: cec_record_source_type = 4;
pub const CEC_RECORD_SOURCE_TYPE_EXTERNAL_PHYSICAL_ADDRESS: cec_record_source_type = 5;
pub type cec_record_source_type = u32;
pub const CEC_RECORD_STATUS_INFO_RECORDING_CURRENTLY_SELECTED_SOURCE: cec_record_status_info = 1;
pub const CEC_RECORD_STATUS_INFO_RECORDING_DIGITAL_SERVICE: cec_record_status_info = 2;
pub const CEC_RECORD_STATUS_INFO_RECORDING_ANALOGUE_SERVICE: cec_record_status_info = 3;
pub const CEC_RECORD_STATUS_INFO_RECORDING_EXTERNAL_INPUT: cec_record_status_info = 4;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_UNABLE_TO_RECORD_DIGITAL_SERVICE:
    cec_record_status_info = 5;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_UNABLE_TO_RECORD_ANALOGUE_SERVICE:
    cec_record_status_info = 6;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_UNABLE_TO_SELECT_REQUIRED_SERVICE:
    cec_record_status_info = 7;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_INVALID_EXTERNAL_PLUG_NUMBER: cec_record_status_info =
    9;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_INVALID_EXTERNAL_ADDRESS: cec_record_status_info = 10;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_CA_SYSTEM_NOT_SUPPORTED: cec_record_status_info = 11;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_OR_INSUFFICIENT_ENTITLEMENTS:
    cec_record_status_info = 12;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_NOT_ALLOWED_TO_COPY_SOURCE: cec_record_status_info =
    13;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_FURTHER_COPIES_ALLOWED: cec_record_status_info =
    14;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_MEDIA: cec_record_status_info = 16;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_PLAYING: cec_record_status_info = 17;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_ALREADY_RECORDING: cec_record_status_info = 18;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_MEDIA_PROTECTED: cec_record_status_info = 19;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_SOURCE_SIGNAL: cec_record_status_info = 20;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_MEDIA_PROBLEM: cec_record_status_info = 21;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_NOT_ENOUGH_SPACE_AVAILABLE: cec_record_status_info =
    22;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_PARENTAL_LOCK_ON: cec_record_status_info = 23;
pub const CEC_RECORD_STATUS_INFO_RECORDING_TERMINATED_NORMALLY: cec_record_status_info = 26;
pub const CEC_RECORD_STATUS_INFO_RECORDING_HAS_ALREADY_TERMINATED: cec_record_status_info = 27;
pub const CEC_RECORD_STATUS_INFO_NO_RECORDING_OTHER_REASON: cec_record_status_info = 31;
pub type cec_record_status_info = u32;
pub const CEC_RECORDING_SEQUENCE_SUNDAY: cec_recording_sequence = 1;
pub const CEC_RECORDING_SEQUENCE_MONDAY: cec_recording_sequence = 2;
pub const CEC_RECORDING_SEQUENCE_TUESDAY: cec_recording_sequence = 4;
pub const CEC_RECORDING_SEQUENCE_WEDNESDAY: cec_recording_sequence = 8;
pub const CEC_RECORDING_SEQUENCE_THURSDAY: cec_recording_sequence = 16;
pub const CEC_RECORDING_SEQUENCE_FRIDAY: cec_recording_sequence = 32;
pub const CEC_RECORDING_SEQUENCE_SATURDAY: cec_recording_sequence = 64;
pub const CEC_RECORDING_SEQUENCE_ONCE_ONLY: cec_recording_sequence = 0;
pub type cec_recording_sequence = u32;
pub const CEC_STATUS_REQUEST_ON: cec_status_request = 1;
pub const CEC_STATUS_REQUEST_OFF: cec_status_request = 2;
pub const CEC_STATUS_REQUEST_ONCE: cec_status_request = 3;
pub type cec_status_request = u32;
pub const CEC_SYSTEM_AUDIO_STATUS_OFF: cec_system_audio_status = 0;
pub const CEC_SYSTEM_AUDIO_STATUS_ON: cec_system_audio_status = 1;
pub type cec_system_audio_status = u32;
pub const CEC_TIMER_CLEARED_STATUS_DATA_TIMER_NOT_CLEARED_RECORDING: cec_timer_cleared_status_data =
    0;
pub const CEC_TIMER_CLEARED_STATUS_DATA_TIMER_NOT_CLEARED_NO_MATCHING:
    cec_timer_cleared_status_data = 1;
pub const CEC_TIMER_CLEARED_STATUS_DATA_TIMER_NOT_CLEARED_NO_INF0_AVAILABLE:
    cec_timer_cleared_status_data = 2;
pub const CEC_TIMER_CLEARED_STATUS_DATA_TIMER_CLEARED: cec_timer_cleared_status_data = 128;
pub type cec_timer_cleared_status_data = u32;
pub const CEC_TIMER_OVERLAP_WARNING_NO_OVERLAP: cec_timer_overlap_warning = 0;
pub const CEC_TIMER_OVERLAP_WARNING_TIMER_BLOCKS_OVERLAP: cec_timer_overlap_warning = 1;
pub type cec_timer_overlap_warning = u32;
pub const CEC_MEDIA_INFO_MEDIA_PRESENT_AND_NOT_PROTECTED: cec_media_info = 0;
pub const CEC_MEDIA_INFO_MEDIA_PRESENT_BUT_PROTECTED: cec_media_info = 1;
pub const CEC_MEDIA_INFO_MEDIA_NOT_PRESENT: cec_media_info = 2;
pub const CEC_MEDIA_INFO_FUTURE_USE: cec_media_info = 3;
pub type cec_media_info = u32;
pub const CEC_PROGRAMMED_INDICATOR_NOT_PROGRAMMED: cec_programmed_indicator = 0;
pub const CEC_PROGRAMMED_INDICATOR_PROGRAMMED: cec_programmed_indicator = 1;
pub type cec_programmed_indicator = u32;
pub const CEC_PROGRAMMED_INFO_FUTURE_USE: cec_programmed_info = 0;
pub const CEC_PROGRAMMED_INFO_ENOUGH_SPACE_AVAILABLE_FOR_RECORDING: cec_programmed_info = 8;
pub const CEC_PROGRAMMED_INFO_NOT_ENOUGH_SPACE_AVAILABLE_FOR_RECORDING: cec_programmed_info = 9;
pub const CEC_PROGRAMMED_INFO_MAY_NOT_BE_ENOUGH_SPACE_AVAILABLE: cec_programmed_info = 11;
pub const CEC_PROGRAMMED_INFO_NO_MEDIA_INFO_AVAILABLE: cec_programmed_info = 10;
pub type cec_programmed_info = u32;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_FUTURE_USE: cec_not_programmed_error_info = 0;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_NO_FREE_TIMER_AVAILABLE: cec_not_programmed_error_info = 1;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_DATE_OUT_OF_RANGE: cec_not_programmed_error_info = 2;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_RECORDING_SEQUENCE_ERROR: cec_not_programmed_error_info = 3;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_INVALID_EXTERNAL_PLUG_NUMBER:
    cec_not_programmed_error_info = 4;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_INVALID_EXTERNAL_PHYSICAL_ADDRESS:
    cec_not_programmed_error_info = 5;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_CA_SYSTEM_NOT_SUPPORTED: cec_not_programmed_error_info = 6;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS:
    cec_not_programmed_error_info = 7;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_DOES_NOT_SUPPORT_RESOLUTION: cec_not_programmed_error_info =
    8;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_PARENTAL_LOCK_ON: cec_not_programmed_error_info = 9;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_CLOCK_FAILURE: cec_not_programmed_error_info = 10;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_RESERVED_FOR_FUTURE_USE_START:
    cec_not_programmed_error_info = 11;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_RESERVED_FOR_FUTURE_USE_END: cec_not_programmed_error_info =
    13;
pub const CEC_NOT_PROGRAMMED_ERROR_INFO_DUPLICATE_ALREADY_PROGRAMMED:
    cec_not_programmed_error_info = 14;
pub type cec_not_programmed_error_info = u32;
pub const CEC_RECORDING_FLAG_NOT_BEING_USED_FOR_RECORDING: cec_recording_flag = 0;
pub const CEC_RECORDING_FLAG_BEING_USED_FOR_RECORDING: cec_recording_flag = 1;
pub type cec_recording_flag = u32;
pub const CEC_TUNER_DISPLAY_INFO_DISPLAYING_DIGITAL_TUNER: cec_tuner_display_info = 0;
pub const CEC_TUNER_DISPLAY_INFO_NOT_DISPLAYING_TUNER: cec_tuner_display_info = 1;
pub const CEC_TUNER_DISPLAY_INFO_DISPLAYING_ANALOGUE_TUNER: cec_tuner_display_info = 2;
pub type cec_tuner_display_info = u32;
pub const CEC_BROADCAST_SYSTEM_PAL_B_G: cec_broadcast_system = 0;
pub const CEC_BROADCAST_SYSTEM_SECAM_L1: cec_broadcast_system = 1;
pub const CEC_BROADCAST_SYSTEM_PAL_M: cec_broadcast_system = 2;
pub const CEC_BROADCAST_SYSTEM_NTSC_M: cec_broadcast_system = 3;
pub const CEC_BROADCAST_SYSTEM_PAL_I: cec_broadcast_system = 4;
pub const CEC_BROADCAST_SYSTEM_SECAM_DK: cec_broadcast_system = 5;
pub const CEC_BROADCAST_SYSTEM_SECAM_B_G: cec_broadcast_system = 6;
pub const CEC_BROADCAST_SYSTEM_SECAM_L2: cec_broadcast_system = 7;
pub const CEC_BROADCAST_SYSTEM_PAL_DK: cec_broadcast_system = 8;
pub const CEC_BROADCAST_SYSTEM_OTHER_SYSTEM: cec_broadcast_system = 30;
pub type cec_broadcast_system = u32;
pub const CEC_USER_CONTROL_CODE_SELECT: cec_user_control_code = 0;
pub const CEC_USER_CONTROL_CODE_UP: cec_user_control_code = 1;
pub const CEC_USER_CONTROL_CODE_DOWN: cec_user_control_code = 2;
pub const CEC_USER_CONTROL_CODE_LEFT: cec_user_control_code = 3;
pub const CEC_USER_CONTROL_CODE_RIGHT: cec_user_control_code = 4;
pub const CEC_USER_CONTROL_CODE_RIGHT_UP: cec_user_control_code = 5;
pub const CEC_USER_CONTROL_CODE_RIGHT_DOWN: cec_user_control_code = 6;
pub const CEC_USER_CONTROL_CODE_LEFT_UP: cec_user_control_code = 7;
pub const CEC_USER_CONTROL_CODE_LEFT_DOWN: cec_user_control_code = 8;
pub const CEC_USER_CONTROL_CODE_ROOT_MENU: cec_user_control_code = 9;
pub const CEC_USER_CONTROL_CODE_SETUP_MENU: cec_user_control_code = 10;
pub const CEC_USER_CONTROL_CODE_CONTENTS_MENU: cec_user_control_code = 11;
pub const CEC_USER_CONTROL_CODE_FAVORITE_MENU: cec_user_control_code = 12;
pub const CEC_USER_CONTROL_CODE_EXIT: cec_user_control_code = 13;
pub const CEC_USER_CONTROL_CODE_TOP_MENU: cec_user_control_code = 16;
pub const CEC_USER_CONTROL_CODE_DVD_MENU: cec_user_control_code = 17;
pub const CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE: cec_user_control_code = 29;
pub const CEC_USER_CONTROL_CODE_NUMBER11: cec_user_control_code = 30;
pub const CEC_USER_CONTROL_CODE_NUMBER12: cec_user_control_code = 31;
pub const CEC_USER_CONTROL_CODE_NUMBER0: cec_user_control_code = 32;
pub const CEC_USER_CONTROL_CODE_NUMBER1: cec_user_control_code = 33;
pub const CEC_USER_CONTROL_CODE_NUMBER2: cec_user_control_code = 34;
pub const CEC_USER_CONTROL_CODE_NUMBER3: cec_user_control_code = 35;
pub const CEC_USER_CONTROL_CODE_NUMBER4: cec_user_control_code = 36;
pub const CEC_USER_CONTROL_CODE_NUMBER5: cec_user_control_code = 37;
pub const CEC_USER_CONTROL_CODE_NUMBER6: cec_user_control_code = 38;
pub const CEC_USER_CONTROL_CODE_NUMBER7: cec_user_control_code = 39;
pub const CEC_USER_CONTROL_CODE_NUMBER8: cec_user_control_code = 40;
pub const CEC_USER_CONTROL_CODE_NUMBER9: cec_user_control_code = 41;
pub const CEC_USER_CONTROL_CODE_DOT: cec_user_control_code = 42;
pub const CEC_USER_CONTROL_CODE_ENTER: cec_user_control_code = 43;
pub const CEC_USER_CONTROL_CODE_CLEAR: cec_user_control_code = 44;
pub const CEC_USER_CONTROL_CODE_NEXT_FAVORITE: cec_user_control_code = 47;
pub const CEC_USER_CONTROL_CODE_CHANNEL_UP: cec_user_control_code = 48;
pub const CEC_USER_CONTROL_CODE_CHANNEL_DOWN: cec_user_control_code = 49;
pub const CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL: cec_user_control_code = 50;
pub const CEC_USER_CONTROL_CODE_SOUND_SELECT: cec_user_control_code = 51;
pub const CEC_USER_CONTROL_CODE_INPUT_SELECT: cec_user_control_code = 52;
pub const CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION: cec_user_control_code = 53;
pub const CEC_USER_CONTROL_CODE_HELP: cec_user_control_code = 54;
pub const CEC_USER_CONTROL_CODE_PAGE_UP: cec_user_control_code = 55;
pub const CEC_USER_CONTROL_CODE_PAGE_DOWN: cec_user_control_code = 56;
pub const CEC_USER_CONTROL_CODE_POWER: cec_user_control_code = 64;
pub const CEC_USER_CONTROL_CODE_VOLUME_UP: cec_user_control_code = 65;
pub const CEC_USER_CONTROL_CODE_VOLUME_DOWN: cec_user_control_code = 66;
pub const CEC_USER_CONTROL_CODE_MUTE: cec_user_control_code = 67;
pub const CEC_USER_CONTROL_CODE_PLAY: cec_user_control_code = 68;
pub const CEC_USER_CONTROL_CODE_STOP: cec_user_control_code = 69;
pub const CEC_USER_CONTROL_CODE_PAUSE: cec_user_control_code = 70;
pub const CEC_USER_CONTROL_CODE_RECORD: cec_user_control_code = 71;
pub const CEC_USER_CONTROL_CODE_REWIND: cec_user_control_code = 72;
pub const CEC_USER_CONTROL_CODE_FAST_FORWARD: cec_user_control_code = 73;
pub const CEC_USER_CONTROL_CODE_EJECT: cec_user_control_code = 74;
pub const CEC_USER_CONTROL_CODE_FORWARD: cec_user_control_code = 75;
pub const CEC_USER_CONTROL_CODE_BACKWARD: cec_user_control_code = 76;
pub const CEC_USER_CONTROL_CODE_STOP_RECORD: cec_user_control_code = 77;
pub const CEC_USER_CONTROL_CODE_PAUSE_RECORD: cec_user_control_code = 78;
pub const CEC_USER_CONTROL_CODE_ANGLE: cec_user_control_code = 80;
pub const CEC_USER_CONTROL_CODE_SUB_PICTURE: cec_user_control_code = 81;
pub const CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND: cec_user_control_code = 82;
pub const CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE: cec_user_control_code = 83;
pub const CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING: cec_user_control_code = 84;
pub const CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION: cec_user_control_code = 85;
pub const CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE: cec_user_control_code = 86;
pub const CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION: cec_user_control_code = 87;
pub const CEC_USER_CONTROL_CODE_PLAY_FUNCTION: cec_user_control_code = 96;
pub const CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION: cec_user_control_code = 97;
pub const CEC_USER_CONTROL_CODE_RECORD_FUNCTION: cec_user_control_code = 98;
pub const CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION: cec_user_control_code = 99;
pub const CEC_USER_CONTROL_CODE_STOP_FUNCTION: cec_user_control_code = 100;
pub const CEC_USER_CONTROL_CODE_MUTE_FUNCTION: cec_user_control_code = 101;
pub const CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION: cec_user_control_code = 102;
pub const CEC_USER_CONTROL_CODE_TUNE_FUNCTION: cec_user_control_code = 103;
pub const CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION: cec_user_control_code = 104;
pub const CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION: cec_user_control_code = 105;
pub const CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION: cec_user_control_code = 106;
pub const CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION: cec_user_control_code = 107;
pub const CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION: cec_user_control_code = 108;
pub const CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION: cec_user_control_code = 109;
pub const CEC_USER_CONTROL_CODE_F1_BLUE: cec_user_control_code = 113;
pub const CEC_USER_CONTROL_CODE_F2_RED: cec_user_control_code = 114;
pub const CEC_USER_CONTROL_CODE_F3_GREEN: cec_user_control_code = 115;
pub const CEC_USER_CONTROL_CODE_F4_YELLOW: cec_user_control_code = 116;
pub const CEC_USER_CONTROL_CODE_F5: cec_user_control_code = 117;
pub const CEC_USER_CONTROL_CODE_DATA: cec_user_control_code = 118;
pub const CEC_USER_CONTROL_CODE_AN_RETURN: cec_user_control_code = 145;
pub const CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST: cec_user_control_code = 150;
pub const CEC_USER_CONTROL_CODE_MAX: cec_user_control_code = 150;
pub const CEC_USER_CONTROL_CODE_UNKNOWN: cec_user_control_code = 255;
pub type cec_user_control_code = u32;
pub const CECDEVICE_UNKNOWN: cec_logical_address = -1;
pub const CECDEVICE_TV: cec_logical_address = 0;
pub const CECDEVICE_RECORDINGDEVICE1: cec_logical_address = 1;
pub const CECDEVICE_RECORDINGDEVICE2: cec_logical_address = 2;
pub const CECDEVICE_TUNER1: cec_logical_address = 3;
pub const CECDEVICE_PLAYBACKDEVICE1: cec_logical_address = 4;
pub const CECDEVICE_AUDIOSYSTEM: cec_logical_address = 5;
pub const CECDEVICE_TUNER2: cec_logical_address = 6;
pub const CECDEVICE_TUNER3: cec_logical_address = 7;
pub const CECDEVICE_PLAYBACKDEVICE2: cec_logical_address = 8;
pub const CECDEVICE_RECORDINGDEVICE3: cec_logical_address = 9;
pub const CECDEVICE_TUNER4: cec_logical_address = 10;
pub const CECDEVICE_PLAYBACKDEVICE3: cec_logical_address = 11;
pub const CECDEVICE_RESERVED1: cec_logical_address = 12;
pub const CECDEVICE_RESERVED2: cec_logical_address = 13;
pub const CECDEVICE_FREEUSE: cec_logical_address = 14;
pub const CECDEVICE_UNREGISTERED: cec_logical_address = 15;
pub const CECDEVICE_BROADCAST: cec_logical_address = 15;
pub type cec_logical_address = i32;
pub const CEC_OPCODE_ACTIVE_SOURCE: cec_opcode = 130;
pub const CEC_OPCODE_IMAGE_VIEW_ON: cec_opcode = 4;
pub const CEC_OPCODE_TEXT_VIEW_ON: cec_opcode = 13;
pub const CEC_OPCODE_INACTIVE_SOURCE: cec_opcode = 157;
pub const CEC_OPCODE_REQUEST_ACTIVE_SOURCE: cec_opcode = 133;
pub const CEC_OPCODE_ROUTING_CHANGE: cec_opcode = 128;
pub const CEC_OPCODE_ROUTING_INFORMATION: cec_opcode = 129;
pub const CEC_OPCODE_SET_STREAM_PATH: cec_opcode = 134;
pub const CEC_OPCODE_STANDBY: cec_opcode = 54;
pub const CEC_OPCODE_RECORD_OFF: cec_opcode = 11;
pub const CEC_OPCODE_RECORD_ON: cec_opcode = 9;
pub const CEC_OPCODE_RECORD_STATUS: cec_opcode = 10;
pub const CEC_OPCODE_RECORD_TV_SCREEN: cec_opcode = 15;
pub const CEC_OPCODE_CLEAR_ANALOGUE_TIMER: cec_opcode = 51;
pub const CEC_OPCODE_CLEAR_DIGITAL_TIMER: cec_opcode = 153;
pub const CEC_OPCODE_CLEAR_EXTERNAL_TIMER: cec_opcode = 161;
pub const CEC_OPCODE_SET_ANALOGUE_TIMER: cec_opcode = 52;
pub const CEC_OPCODE_SET_DIGITAL_TIMER: cec_opcode = 151;
pub const CEC_OPCODE_SET_EXTERNAL_TIMER: cec_opcode = 162;
pub const CEC_OPCODE_SET_TIMER_PROGRAM_TITLE: cec_opcode = 103;
pub const CEC_OPCODE_TIMER_CLEARED_STATUS: cec_opcode = 67;
pub const CEC_OPCODE_TIMER_STATUS: cec_opcode = 53;
pub const CEC_OPCODE_CEC_VERSION: cec_opcode = 158;
pub const CEC_OPCODE_GET_CEC_VERSION: cec_opcode = 159;
pub const CEC_OPCODE_GIVE_PHYSICAL_ADDRESS: cec_opcode = 131;
pub const CEC_OPCODE_GET_MENU_LANGUAGE: cec_opcode = 145;
pub const CEC_OPCODE_REPORT_PHYSICAL_ADDRESS: cec_opcode = 132;
pub const CEC_OPCODE_SET_MENU_LANGUAGE: cec_opcode = 50;
pub const CEC_OPCODE_DECK_CONTROL: cec_opcode = 66;
pub const CEC_OPCODE_DECK_STATUS: cec_opcode = 27;
pub const CEC_OPCODE_GIVE_DECK_STATUS: cec_opcode = 26;
pub const CEC_OPCODE_PLAY: cec_opcode = 65;
pub const CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS: cec_opcode = 8;
pub const CEC_OPCODE_SELECT_ANALOGUE_SERVICE: cec_opcode = 146;
pub const CEC_OPCODE_SELECT_DIGITAL_SERVICE: cec_opcode = 147;
pub const CEC_OPCODE_TUNER_DEVICE_STATUS: cec_opcode = 7;
pub const CEC_OPCODE_TUNER_STEP_DECREMENT: cec_opcode = 6;
pub const CEC_OPCODE_TUNER_STEP_INCREMENT: cec_opcode = 5;
pub const CEC_OPCODE_DEVICE_VENDOR_ID: cec_opcode = 135;
pub const CEC_OPCODE_GIVE_DEVICE_VENDOR_ID: cec_opcode = 140;
pub const CEC_OPCODE_VENDOR_COMMAND: cec_opcode = 137;
pub const CEC_OPCODE_VENDOR_COMMAND_WITH_ID: cec_opcode = 160;
pub const CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN: cec_opcode = 138;
pub const CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP: cec_opcode = 139;
pub const CEC_OPCODE_SET_OSD_STRING: cec_opcode = 100;
pub const CEC_OPCODE_GIVE_OSD_NAME: cec_opcode = 70;
pub const CEC_OPCODE_SET_OSD_NAME: cec_opcode = 71;
pub const CEC_OPCODE_MENU_REQUEST: cec_opcode = 141;
pub const CEC_OPCODE_MENU_STATUS: cec_opcode = 142;
pub const CEC_OPCODE_USER_CONTROL_PRESSED: cec_opcode = 68;
pub const CEC_OPCODE_USER_CONTROL_RELEASE: cec_opcode = 69;
pub const CEC_OPCODE_GIVE_DEVICE_POWER_STATUS: cec_opcode = 143;
pub const CEC_OPCODE_REPORT_POWER_STATUS: cec_opcode = 144;
pub const CEC_OPCODE_FEATURE_ABORT: cec_opcode = 0;
pub const CEC_OPCODE_ABORT: cec_opcode = 255;
pub const CEC_OPCODE_GIVE_AUDIO_STATUS: cec_opcode = 113;
pub const CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS: cec_opcode = 125;
pub const CEC_OPCODE_REPORT_AUDIO_STATUS: cec_opcode = 122;
pub const CEC_OPCODE_SET_SYSTEM_AUDIO_MODE: cec_opcode = 114;
pub const CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST: cec_opcode = 112;
pub const CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS: cec_opcode = 126;
pub const CEC_OPCODE_SET_AUDIO_RATE: cec_opcode = 154;
pub const CEC_OPCODE_START_ARC: cec_opcode = 192;
pub const CEC_OPCODE_REPORT_ARC_STARTED: cec_opcode = 193;
pub const CEC_OPCODE_REPORT_ARC_ENDED: cec_opcode = 194;
pub const CEC_OPCODE_REQUEST_ARC_START: cec_opcode = 195;
pub const CEC_OPCODE_REQUEST_ARC_END: cec_opcode = 196;
pub const CEC_OPCODE_END_ARC: cec_opcode = 197;
pub const CEC_OPCODE_CDC: cec_opcode = 248;
pub const CEC_OPCODE_NONE: cec_opcode = 253;
pub type cec_opcode = u32;
pub const CEC_LOG_ERROR: cec_log_level = 1;
pub const CEC_LOG_WARNING: cec_log_level = 2;
pub const CEC_LOG_NOTICE: cec_log_level = 4;
pub const CEC_LOG_TRAFFIC: cec_log_level = 8;
pub const CEC_LOG_DEBUG: cec_log_level = 16;
pub const CEC_LOG_ALL: cec_log_level = 31;
pub type cec_log_level = u32;
pub const CEC_DEVICE_STATUS_UNKNOWN: cec_bus_device_status = 0;
pub const CEC_DEVICE_STATUS_PRESENT: cec_bus_device_status = 1;
pub const CEC_DEVICE_STATUS_NOT_PRESENT: cec_bus_device_status = 2;
pub const CEC_DEVICE_STATUS_HANDLED_BY_LIBCEC: cec_bus_device_status = 3;
pub type cec_bus_device_status = u32;
pub const CEC_VENDOR_TOSHIBA: cec_vendor_id = 57;
pub const CEC_VENDOR_SAMSUNG: cec_vendor_id = 240;
pub const CEC_VENDOR_DENON: cec_vendor_id = 1485;
pub const CEC_VENDOR_MARANTZ: cec_vendor_id = 1656;
pub const CEC_VENDOR_LOEWE: cec_vendor_id = 2434;
pub const CEC_VENDOR_ONKYO: cec_vendor_id = 2480;
pub const CEC_VENDOR_MEDION: cec_vendor_id = 3256;
pub const CEC_VENDOR_TOSHIBA2: cec_vendor_id = 3303;
pub const CEC_VENDOR_PULSE_EIGHT: cec_vendor_id = 5506;
pub const CEC_VENDOR_HARMAN_KARDON2: cec_vendor_id = 6480;
pub const CEC_VENDOR_GOOGLE: cec_vendor_id = 6673;
pub const CEC_VENDOR_AKAI: cec_vendor_id = 8391;
pub const CEC_VENDOR_AOC: cec_vendor_id = 9319;
pub const CEC_VENDOR_PANASONIC: cec_vendor_id = 32837;
pub const CEC_VENDOR_PHILIPS: cec_vendor_id = 36926;
pub const CEC_VENDOR_DAEWOO: cec_vendor_id = 36947;
pub const CEC_VENDOR_YAMAHA: cec_vendor_id = 41182;
pub const CEC_VENDOR_GRUNDIG: cec_vendor_id = 53461;
pub const CEC_VENDOR_PIONEER: cec_vendor_id = 57398;
pub const CEC_VENDOR_LG: cec_vendor_id = 57489;
pub const CEC_VENDOR_SHARP: cec_vendor_id = 524319;
pub const CEC_VENDOR_SONY: cec_vendor_id = 524358;
pub const CEC_VENDOR_BROADCOM: cec_vendor_id = 1622150;
pub const CEC_VENDOR_SHARP2: cec_vendor_id = 5458000;
pub const CEC_VENDOR_VIZIO: cec_vendor_id = 7042157;
pub const CEC_VENDOR_BENQ: cec_vendor_id = 8414697;
pub const CEC_VENDOR_HARMAN_KARDON: cec_vendor_id = 10249310;
pub const CEC_VENDOR_UNKNOWN: cec_vendor_id = 0;
pub type cec_vendor_id = u32;
pub const ADAPTERTYPE_UNKNOWN: cec_adapter_type = 0;
pub const ADAPTERTYPE_P8_EXTERNAL: cec_adapter_type = 1;
pub const ADAPTERTYPE_P8_DAUGHTERBOARD: cec_adapter_type = 2;
pub const ADAPTERTYPE_RPI: cec_adapter_type = 256;
pub const ADAPTERTYPE_TDA995x: cec_adapter_type = 512;
pub const ADAPTERTYPE_EXYNOS: cec_adapter_type = 768;
pub const ADAPTERTYPE_AOCEC: cec_adapter_type = 1280;
pub type cec_adapter_type = u32;
pub const LIBCEC_VERSION_CURRENT: libcec_version = 262146;
#[doc = " force exporting through swig"]
pub type libcec_version = u32;
pub type cec_menu_language = [::std::os::raw::c_char; 4usize];
pub type cec_osd_name = [::std::os::raw::c_char; 14usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_log_message {
    #[doc = "< the actual message, valid until returning from the log callback"]
    pub message: *const ::std::os::raw::c_char,
    #[doc = "< log level of the message"]
    pub level: cec_log_level,
    #[doc = "< the timestamp of this message"]
    pub time: i64,
}
#[test]
fn bindgen_test_layout_cec_log_message() {
    assert_eq!(
        ::std::mem::size_of::<cec_log_message>(),
        24usize,
        concat!("Size of: ", stringify!(cec_log_message))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_log_message>(),
        8usize,
        concat!("Alignment of ", stringify!(cec_log_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_log_message>())).message as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_log_message),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_log_message>())).level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_log_message),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_log_message>())).time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_log_message),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_keypress {
    #[doc = "< the keycode"]
    pub keycode: cec_user_control_code,
    #[doc = "< the duration of the keypress"]
    pub duration: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_cec_keypress() {
    assert_eq!(
        ::std::mem::size_of::<cec_keypress>(),
        8usize,
        concat!("Size of: ", stringify!(cec_keypress))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_keypress>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_keypress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_keypress>())).keycode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_keypress),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_keypress>())).duration as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_keypress),
            "::",
            stringify!(duration)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cec_adapter {
    #[doc = "< the path to the com port"]
    pub path: [::std::os::raw::c_char; 1024usize],
    #[doc = "< the name of the com port"]
    pub comm: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_cec_adapter() {
    assert_eq!(
        ::std::mem::size_of::<cec_adapter>(),
        2048usize,
        concat!("Size of: ", stringify!(cec_adapter))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_adapter>(),
        1usize,
        concat!("Alignment of ", stringify!(cec_adapter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_adapter>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_adapter>())).comm as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter),
            "::",
            stringify!(comm)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cec_adapter_descriptor {
    #[doc = "< the path to the com port"]
    pub strComPath: [::std::os::raw::c_char; 1024usize],
    #[doc = "< the name of the com port"]
    pub strComName: [::std::os::raw::c_char; 1024usize],
    pub iVendorId: u16,
    pub iProductId: u16,
    pub iFirmwareVersion: u16,
    pub iPhysicalAddress: u16,
    pub iFirmwareBuildDate: u32,
    pub adapterType: cec_adapter_type,
}
#[test]
fn bindgen_test_layout_cec_adapter_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<cec_adapter_descriptor>(),
        2064usize,
        concat!("Size of: ", stringify!(cec_adapter_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_adapter_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_adapter_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).strComPath as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(strComPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).strComName as *const _ as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(strComName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).iVendorId as *const _ as usize
        },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iVendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).iProductId as *const _ as usize
        },
        2050usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iProductId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).iFirmwareVersion as *const _ as usize
        },
        2052usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iFirmwareVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).iPhysicalAddress as *const _ as usize
        },
        2054usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iPhysicalAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).iFirmwareBuildDate as *const _
                as usize
        },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iFirmwareBuildDate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cec_adapter_descriptor>())).adapterType as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(adapterType)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cec_datapacket {
    #[doc = "< the actual data"]
    pub data: [u8; 64usize],
    #[doc = "< the size of the data"]
    pub size: u8,
}
#[test]
fn bindgen_test_layout_cec_datapacket() {
    assert_eq!(
        ::std::mem::size_of::<cec_datapacket>(),
        65usize,
        concat!("Size of: ", stringify!(cec_datapacket))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_datapacket>(),
        1usize,
        concat!("Alignment of ", stringify!(cec_datapacket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_datapacket>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_datapacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_datapacket>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_datapacket),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cec_command {
    #[doc = "< the logical address of the initiator of this message"]
    pub initiator: cec_logical_address,
    #[doc = "< the logical address of the destination of this message"]
    pub destination: cec_logical_address,
    #[doc = "< 1 when the ACK bit is set, 0 otherwise"]
    pub ack: i8,
    #[doc = "< 1 when the EOM bit is set, 0 otherwise"]
    pub eom: i8,
    #[doc = "< the opcode of this message"]
    pub opcode: cec_opcode,
    #[doc = "< the parameters attached to this message"]
    pub parameters: cec_datapacket,
    #[doc = "< 1 when an opcode is set, 0 otherwise (POLL message)"]
    pub opcode_set: i8,
    #[doc = "< the timeout to use in ms"]
    pub transmit_timeout: i32,
}
#[test]
fn bindgen_test_layout_cec_command() {
    assert_eq!(
        ::std::mem::size_of::<cec_command>(),
        88usize,
        concat!("Size of: ", stringify!(cec_command))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_command>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_command))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).initiator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(initiator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).destination as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).ack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(ack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).eom as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(eom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).opcode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).parameters as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).opcode_set as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(opcode_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_command>())).transmit_timeout as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(transmit_timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_device_type_list {
    #[doc = "< the list of device types"]
    pub types: [cec_device_type; 5usize],
}
#[test]
fn bindgen_test_layout_cec_device_type_list() {
    assert_eq!(
        ::std::mem::size_of::<cec_device_type_list>(),
        20usize,
        concat!("Size of: ", stringify!(cec_device_type_list))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_device_type_list>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_device_type_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_device_type_list>())).types as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_device_type_list),
            "::",
            stringify!(types)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_logical_addresses {
    #[doc = "< the primary logical address to use"]
    pub primary: cec_logical_address,
    #[doc = "< the list of addresses"]
    pub addresses: [::std::os::raw::c_int; 16usize],
}
#[test]
fn bindgen_test_layout_cec_logical_addresses() {
    assert_eq!(
        ::std::mem::size_of::<cec_logical_addresses>(),
        68usize,
        concat!("Size of: ", stringify!(cec_logical_addresses))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_logical_addresses>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_logical_addresses))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_logical_addresses>())).primary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_logical_addresses),
            "::",
            stringify!(primary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cec_logical_addresses>())).addresses as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_logical_addresses),
            "::",
            stringify!(addresses)
        )
    );
}
pub const CEC_ALERT_SERVICE_DEVICE: libcec_alert = 0;
pub const CEC_ALERT_CONNECTION_LOST: libcec_alert = 1;
pub const CEC_ALERT_PERMISSION_ERROR: libcec_alert = 2;
pub const CEC_ALERT_PORT_BUSY: libcec_alert = 3;
pub const CEC_ALERT_PHYSICAL_ADDRESS_ERROR: libcec_alert = 4;
pub const CEC_ALERT_TV_POLL_FAILED: libcec_alert = 5;
pub type libcec_alert = u32;
pub const CEC_PARAMETER_TYPE_STRING: libcec_parameter_type = 0;
pub const CEC_PARAMETER_TYPE_UNKOWN: libcec_parameter_type = 1;
pub type libcec_parameter_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libcec_parameter {
    #[doc = "< the type of this parameter"]
    pub paramType: libcec_parameter_type,
    #[doc = "< the value of this parameter"]
    pub paramData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_libcec_parameter() {
    assert_eq!(
        ::std::mem::size_of::<libcec_parameter>(),
        16usize,
        concat!("Size of: ", stringify!(libcec_parameter))
    );
    assert_eq!(
        ::std::mem::align_of::<libcec_parameter>(),
        8usize,
        concat!("Alignment of ", stringify!(libcec_parameter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_parameter>())).paramType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_parameter),
            "::",
            stringify!(paramType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_parameter>())).paramData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_parameter),
            "::",
            stringify!(paramData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ICECCallbacks {
    #[doc = " @brief Transfer a log message from libCEC to the client."]
    #[doc = " @param cbparam             Callback parameter provided when the callbacks were set up"]
    #[doc = " @param message             The message to transfer."]
    pub logMessage: ::std::option::Option<
        unsafe extern "C" fn(cbparam: *mut ::std::os::raw::c_void, message: *const cec_log_message),
    >,
    #[doc = " @brief Transfer a keypress from libCEC to the client."]
    #[doc = " @param cbparam             Callback parameter provided when the callbacks were set up"]
    #[doc = " @param key                 The keypress to transfer."]
    pub keyPress: ::std::option::Option<
        unsafe extern "C" fn(cbparam: *mut ::std::os::raw::c_void, key: *const cec_keypress),
    >,
    #[doc = " @brief Transfer a CEC command from libCEC to the client."]
    #[doc = " @param cbparam             Callback parameter provided when the callbacks were set up"]
    #[doc = " @param command             The command to transfer."]
    pub commandReceived: ::std::option::Option<
        unsafe extern "C" fn(cbparam: *mut ::std::os::raw::c_void, command: *const cec_command),
    >,
    #[doc = " @brief Transfer a changed configuration from libCEC to the client"]
    #[doc = " @param cbparam             Callback parameter provided when the callbacks were set up"]
    #[doc = " @param configuration       The configuration to transfer"]
    pub configurationChanged: ::std::option::Option<
        unsafe extern "C" fn(
            cbparam: *mut ::std::os::raw::c_void,
            configuration: *const libcec_configuration,
        ),
    >,
    #[doc = " @brief Transfer a libcec alert message from libCEC to the client"]
    #[doc = " @param cbparam             Callback parameter provided when the callbacks were set up"]
    #[doc = " @param alert               The alert type transfer."]
    #[doc = " @param data                Misc. additional information."]
    pub alert: ::std::option::Option<
        unsafe extern "C" fn(
            cbparam: *mut ::std::os::raw::c_void,
            alert: libcec_alert,
            param: libcec_parameter,
        ),
    >,
    #[doc = " @brief Transfer a menu state change to the client."]
    #[doc = " Transfer a menu state change to the client. If the command returns 1, then the change will be processed by"]
    #[doc = " the busdevice. If 0, then the state of the busdevice won't be changed, and will always be kept 'activated',"]
    #[doc = " @warning CEC does not allow the player to suppress the menu state change on the TV, so the menu on the TV will always be displayed, whatever the return value of this method is."]
    #[doc = " so keypresses are always routed."]
    #[doc = " @param cbparam             Callback parameter provided when the callbacks were set up"]
    #[doc = " @param state               The new value."]
    #[doc = ""]
    #[doc = " @return 1 if libCEC should use this new value, 0 otherwise."]
    pub menuStateChanged: ::std::option::Option<
        unsafe extern "C" fn(
            cbparam: *mut ::std::os::raw::c_void,
            state: cec_menu_state,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Called when a source that's handled by this client is activated."]
    #[doc = " @param cbparam             Callback parameter provided when the callbacks were set up"]
    #[doc = " @param logicalAddress      The address that was just activated."]
    #[doc = " @param bActivated          1 if activated, 0 when deactivated."]
    pub sourceActivated: ::std::option::Option<
        unsafe extern "C" fn(
            cbParam: *mut ::std::os::raw::c_void,
            logicalAddress: cec_logical_address,
            bActivated: u8,
        ),
    >,
}
#[test]
fn bindgen_test_layout_ICECCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<ICECCallbacks>(),
        56usize,
        concat!("Size of: ", stringify!(ICECCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<ICECCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(ICECCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ICECCallbacks>())).logMessage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(logMessage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ICECCallbacks>())).keyPress as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(keyPress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ICECCallbacks>())).commandReceived as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(commandReceived)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ICECCallbacks>())).configurationChanged as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(configurationChanged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ICECCallbacks>())).alert as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(alert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ICECCallbacks>())).menuStateChanged as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(menuStateChanged)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ICECCallbacks>())).sourceActivated as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(sourceActivated)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libcec_configuration {
    #[doc = "< the version of the client that is connecting"]
    pub clientVersion: u32,
    #[doc = "< the device name to use on the CEC bus"]
    pub strDeviceName: [::std::os::raw::c_char; 13usize],
    #[doc = "< the device type(s) to use on the CEC bus for libCEC"]
    pub deviceTypes: cec_device_type_list,
    #[doc = "< (read only) set to 1 by libCEC when the physical address was autodetected"]
    pub bAutodetectAddress: u8,
    #[doc = "< the physical address of the CEC adapter"]
    pub iPhysicalAddress: u16,
    #[doc = "< the logical address of the device to which the adapter is connected. only used when iPhysicalAddress = 0 or when the adapter doesn't support autodetection"]
    pub baseDevice: cec_logical_address,
    #[doc = "< the HDMI port to which the adapter is connected. only used when iPhysicalAddress = 0 or when the adapter doesn't support autodetection"]
    pub iHDMIPort: u8,
    #[doc = "< override the vendor ID of the TV. leave this untouched to autodetect"]
    pub tvVendor: u32,
    #[doc = "< list of devices to wake when initialising libCEC or when calling PowerOnDevices() without any parameter."]
    pub wakeDevices: cec_logical_addresses,
    #[doc = "< list of devices to power off when calling StandbyDevices() without any parameter."]
    pub powerOffDevices: cec_logical_addresses,
    #[doc = "< the version number of the server. read-only"]
    pub serverVersion: u32,
    #[doc = "< true to get the settings from the ROM (if set, and a v2 ROM is present), false to use these settings."]
    pub bGetSettingsFromROM: u8,
    #[doc = "< make libCEC the active source on the bus when starting the player application"]
    pub bActivateSource: u8,
    #[doc = "< put this PC in standby mode when the TV is switched off. only used when bShutdownOnStandby = 0"]
    pub bPowerOffOnStandby: u8,
    #[doc = "< the object to pass along with a call of the callback methods. NULL to ignore"]
    pub callbackParam: *mut ::std::os::raw::c_void,
    #[doc = "< the callback methods to use. set this to NULL when not using callbacks"]
    pub callbacks: *mut ICECCallbacks,
    #[doc = "< (read-only) the current logical addresses. added in 1.5.3"]
    pub logicalAddresses: cec_logical_addresses,
    #[doc = "< (read-only) the firmware version of the adapter. added in 1.6.0"]
    pub iFirmwareVersion: u16,
    #[doc = "< the menu language used by the client. 3 character ISO 639-2 country code. see http://http://www.loc.gov/standards/iso639-2/ added in 1.6.2"]
    pub strDeviceLanguage: [::std::os::raw::c_char; 3usize],
    #[doc = "< (read-only) the build date of the firmware, in seconds since epoch. if not available, this value will be set to 0. added in 1.6.2"]
    pub iFirmwareBuildDate: u32,
    #[doc = "< won't allocate a CCECClient when starting the connection when set (same as monitor mode). added in 1.6.3"]
    pub bMonitorOnly: u8,
    #[doc = "< CEC spec version to use by libCEC. defaults to v1.4. added in 1.8.0"]
    pub cecVersion: cec_version,
    #[doc = "< type of the CEC adapter that we're connected to. added in 1.8.2"]
    pub adapterType: cec_adapter_type,
    #[doc = "< key code that initiates combo keys. defaults to CEC_USER_CONTROL_CODE_F1_BLUE. CEC_USER_CONTROL_CODE_UNKNOWN to disable. added in 2.0.5"]
    pub comboKey: cec_user_control_code,
    #[doc = "< timeout until the combo key is sent as normal keypress"]
    pub iComboKeyTimeoutMs: u32,
    #[doc = "< rate at which buttons autorepeat. 0 means rely on CEC device"]
    pub iButtonRepeatRateMs: u32,
    #[doc = "< duration after last update until a button is considered released"]
    pub iButtonReleaseDelayMs: u32,
    #[doc = "< prevent double taps within this timeout. defaults to 200ms. added in 4.0.0"]
    pub iDoubleTapTimeoutMs: u32,
    #[doc = "< set to 1 to automatically waking an AVR when the source is activated. added in 4.0.0"]
    pub bAutoWakeAVR: u8,
}
#[test]
fn bindgen_test_layout_libcec_configuration() {
    assert_eq!(
        ::std::mem::size_of::<libcec_configuration>(),
        336usize,
        concat!("Size of: ", stringify!(libcec_configuration))
    );
    assert_eq!(
        ::std::mem::align_of::<libcec_configuration>(),
        8usize,
        concat!("Alignment of ", stringify!(libcec_configuration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).clientVersion as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(clientVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).strDeviceName as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(strDeviceName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).deviceTypes as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(deviceTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).bAutodetectAddress as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bAutodetectAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).iPhysicalAddress as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iPhysicalAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_configuration>())).baseDevice as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(baseDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_configuration>())).iHDMIPort as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iHDMIPort)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_configuration>())).tvVendor as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(tvVendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).wakeDevices as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(wakeDevices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).powerOffDevices as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(powerOffDevices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).serverVersion as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(serverVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).bGetSettingsFromROM as *const _
                as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bGetSettingsFromROM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).bActivateSource as *const _ as usize
        },
        197usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bActivateSource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).bPowerOffOnStandby as *const _ as usize
        },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bPowerOffOnStandby)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).callbackParam as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(callbackParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_configuration>())).callbacks as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(callbacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).logicalAddresses as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(logicalAddresses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).iFirmwareVersion as *const _ as usize
        },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iFirmwareVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).strDeviceLanguage as *const _ as usize
        },
        286usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(strDeviceLanguage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).iFirmwareBuildDate as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iFirmwareBuildDate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).bMonitorOnly as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bMonitorOnly)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_configuration>())).cecVersion as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(cecVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).adapterType as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(adapterType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<libcec_configuration>())).comboKey as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(comboKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).iComboKeyTimeoutMs as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iComboKeyTimeoutMs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).iButtonRepeatRateMs as *const _
                as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iButtonRepeatRateMs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).iButtonReleaseDelayMs as *const _
                as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iButtonReleaseDelayMs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).iDoubleTapTimeoutMs as *const _
                as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iDoubleTapTimeoutMs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<libcec_configuration>())).bAutoWakeAVR as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bAutoWakeAVR)
        )
    );
}
pub type libcec_connection_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn libcec_initialise(configuration: *mut libcec_configuration) -> libcec_connection_t;
}
extern "C" {
    pub fn libcec_destroy(connection: libcec_connection_t);
}
extern "C" {
    pub fn libcec_open(
        connection: libcec_connection_t,
        strPort: *const ::std::os::raw::c_char,
        iTimeout: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_close(connection: libcec_connection_t);
}
extern "C" {
    pub fn libcec_clear_configuration(configuration: *mut libcec_configuration);
}
extern "C" {
    pub fn libcec_enable_callbacks(
        connection: libcec_connection_t,
        cbParam: *mut ::std::os::raw::c_void,
        callbacks: *mut ICECCallbacks,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_find_adapters(
        connection: libcec_connection_t,
        deviceList: *mut cec_adapter,
        iBufSize: u8,
        strDevicePath: *const ::std::os::raw::c_char,
    ) -> i8;
}
extern "C" {
    pub fn libcec_ping_adapters(connection: libcec_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_start_bootloader(connection: libcec_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_power_on_devices(
        connection: libcec_connection_t,
        address: cec_logical_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_standby_devices(
        connection: libcec_connection_t,
        address: cec_logical_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_active_source(
        connection: libcec_connection_t,
        type_: cec_device_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_deck_control_mode(
        connection: libcec_connection_t,
        mode: cec_deck_control_mode,
        bSendUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_deck_info(
        connection: libcec_connection_t,
        info: cec_deck_info,
        bSendUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_inactive_view(connection: libcec_connection_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_menu_state(
        connection: libcec_connection_t,
        state: cec_menu_state,
        bSendUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_transmit(
        connection: libcec_connection_t,
        data: *const cec_command,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_logical_address(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_physical_address(
        connection: libcec_connection_t,
        iPhysicalAddress: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_osd_string(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
        duration: cec_display_control,
        strMessage: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_switch_monitoring(
        connection: libcec_connection_t,
        bEnable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_device_cec_version(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> cec_version;
}
extern "C" {
    pub fn libcec_get_device_menu_language(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
        language: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_device_vendor_id(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> u32;
}
extern "C" {
    pub fn libcec_get_device_physical_address(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> u16;
}
extern "C" {
    pub fn libcec_get_active_source(connection: libcec_connection_t) -> cec_logical_address;
}
extern "C" {
    pub fn libcec_is_active_source(
        connection: libcec_connection_t,
        iAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_device_power_status(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> cec_power_status;
}
extern "C" {
    pub fn libcec_poll_device(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_active_devices(connection: libcec_connection_t) -> cec_logical_addresses;
}
extern "C" {
    pub fn libcec_is_active_device(
        connection: libcec_connection_t,
        address: cec_logical_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_is_active_device_type(
        connection: libcec_connection_t,
        type_: cec_device_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_hdmi_port(
        connection: libcec_connection_t,
        baseDevice: cec_logical_address,
        iPort: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_volume_up(
        connection: libcec_connection_t,
        bSendRelease: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_volume_down(
        connection: libcec_connection_t,
        bSendRelease: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_mute_audio(
        connection: libcec_connection_t,
        bSendRelease: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_send_keypress(
        connection: libcec_connection_t,
        iDestination: cec_logical_address,
        key: cec_user_control_code,
        bWait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_send_key_release(
        connection: libcec_connection_t,
        iDestination: cec_logical_address,
        bWait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_device_osd_name(
        connection: libcec_connection_t,
        iAddress: cec_logical_address,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_stream_path_logical(
        connection: libcec_connection_t,
        iAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_stream_path_physical(
        connection: libcec_connection_t,
        iPhysicalAddress: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_logical_addresses(connection: libcec_connection_t) -> cec_logical_addresses;
}
extern "C" {
    pub fn libcec_get_current_configuration(
        connection: libcec_connection_t,
        configuration: *mut libcec_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_can_persist_configuration(
        connection: libcec_connection_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_persist_configuration(
        connection: libcec_connection_t,
        configuration: *mut libcec_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_set_configuration(
        connection: libcec_connection_t,
        configuration: *const libcec_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_rescan_devices(connection: libcec_connection_t);
}
extern "C" {
    pub fn libcec_is_libcec_active_source(connection: libcec_connection_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_device_information(
        connection: libcec_connection_t,
        strPort: *const ::std::os::raw::c_char,
        config: *mut libcec_configuration,
        iTimeoutMs: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn libcec_get_lib_info(connection: libcec_connection_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn libcec_init_video_standalone(connection: libcec_connection_t);
}
extern "C" {
    pub fn libcec_get_adapter_vendor_id(connection: libcec_connection_t) -> u16;
}
extern "C" {
    pub fn libcec_get_adapter_product_id(connection: libcec_connection_t) -> u16;
}
extern "C" {
    pub fn libcec_audio_toggle_mute(connection: libcec_connection_t) -> u8;
}
extern "C" {
    pub fn libcec_audio_mute(connection: libcec_connection_t) -> u8;
}
extern "C" {
    pub fn libcec_audio_unmute(connection: libcec_connection_t) -> u8;
}
extern "C" {
    pub fn libcec_audio_get_status(connection: libcec_connection_t) -> u8;
}
extern "C" {
    pub fn libcec_detect_adapters(
        connection: libcec_connection_t,
        deviceList: *mut cec_adapter_descriptor,
        iBufSize: u8,
        strDevicePath: *const ::std::os::raw::c_char,
        bQuickScan: ::std::os::raw::c_int,
    ) -> i8;
}
extern "C" {
    pub fn libcec_menu_state_to_string(
        state: cec_menu_state,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_cec_version_to_string(
        version: cec_version,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_power_status_to_string(
        status: cec_power_status,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_logical_address_to_string(
        address: cec_logical_address,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_deck_control_mode_to_string(
        mode: cec_deck_control_mode,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_deck_status_to_string(
        status: cec_deck_info,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_opcode_to_string(
        opcode: cec_opcode,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_system_audio_status_to_string(
        mode: cec_system_audio_status,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_audio_status_to_string(
        status: cec_audio_status,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_vendor_id_to_string(
        vendor: cec_vendor_id,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_user_control_key_to_string(
        key: cec_user_control_code,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_adapter_type_to_string(
        type_: cec_adapter_type,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
}
extern "C" {
    pub fn libcec_version_to_string(version: u32, buf: *mut ::std::os::raw::c_char, bufsize: usize);
}
